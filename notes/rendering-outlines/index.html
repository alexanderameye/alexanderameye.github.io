<!-- Made by Alexander Ameye using pure html/css and eleventy ‚ô• -->
<!DOCTYPE html>
<html lang="en">
    <!-- HEAD -->
    <head>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<meta name="description" content="Different techniques for rendering outline effects.">
<meta name="author" content="Alexander Ameye">

<!-- Tells Google not to provide a translation for this document -->
<meta name="google" content="notranslate">

<!-- Identify the software used to build the document -->
<meta name="generator" content="eleventy">

<!-- Open graph -->
<meta property="og:title" content="5 ways to draw an outline">
<meta property="og:description" content="Different techniques for rendering outline effects.">
<meta property="og:type" content="article">
<meta property="og:image" content="undefined/notes/rendering-outlines/cover.png"/>
<meta property="og:image:width" content="1200"/>
<meta property="og:image:height" content="675"/>

<!-- Twitter -->
<meta name="twitter:title" content="5 ways to draw an outline">
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@alexanderameye">
<meta name="twitter:description" content="Different techniques for rendering outline effects.">
<meta name="twitter:image" content="https://alexanderameye.github.io/notes/rendering-outlines/cover.png">
<meta name="twitter:creator" content="@alexanderameye">

<title>5 ways to draw an outline</title>

<!-- CSS -->
<link rel="preload" href="/assets/css/reset.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="/assets/css/reset.css"></noscript>



<style>:root{--image-border-radius:2px}body,html{background-color:var(--body-bg-color);margin:0;padding:0;scroll-behavior:smooth;border:none}.reading-time{text-align:center}.note-date{margin-top:50px;padding-bottom:0;margin-bottom:0;font-size:smaller}.status{display:inline-block;border-radius:5px;margin-bottom:30px;margin-top:30px;font-size:.875rem;line-height:1.25rem;background-color:var(--status-bg);border:0 solid var(--status-text)}.menu ul{list-style-type:none;margin-right:20px;margin-left:20px;padding:0}ul{padding-inline-start:20px;margin-block-start:0px;margin-block-end:0px}.menu ul li{text-align:right;font-family:Inter,serif;font-size:1.2em;padding-top:10px;padding-bottom:10px}.menu{text-align:right;display:none;position:absolute;background-color:var(--navbar-bg-color);box-shadow:-10px 0 30px -15px #0000002b;right:0;position:fixed;z-index:499;top:65px;bottom:0}.menu a{text-decoration:none;color:#000}#toggle{display:none}#toggle:checked+#menu{display:flex}#navbar-desktop{background-color:var(--navbar-bg-color);position:-webkit-sticky;position:sticky;top:0;display:flex;flex-wrap:wrap;align-items:center;justify-content:space-between;padding-top:.5rem;padding-bottom:.5rem;z-index:500;border-bottom:1px solid #f0f0f0}#navbar-mobile{background-color:var(--navbar-bg-color);position:-webkit-sticky;position:sticky;top:0;display:flex;flex-wrap:wrap;flex-direction:row;align-items:center;justify-content:space-between;padding-top:1rem;padding-bottom:1rem;padding-left:5px;padding-right:5px;z-index:500;box-shadow:0 0 2px 0 #0000002b}.small-font{font-size:small}.large-font{font-size:large}.column-page{background-color:var(--projects-page-bg-color);padding-bottom:50px;display:grid;grid-template-areas:"left content right""left footer right"}.wide-column-page{background-color:var(--projects-page-bg-color);padding-bottom:50px;display:grid;grid-template-areas:"left content right""left footer right"}.wide-column-page-content{background-color:var(--content-bg-color);grid-area:content;text-align:justify;position:relative}.column-page-content{background-color:var(--content-bg-color);grid-area:content;position:relative}.notes-list{text-align:right;grid-area:left;list-style-position:inside;list-style:none;margin:0;padding:0}.notes-list-link{text-align:right}.notes-list-link a{text-decoration:none;color:inherit}.notes-list-link a:hover{font-weight:700;font-style:normal}h3 span{font-weight:400}.note-content .download-button{display:inline-block;padding:.25rem .5rem;border-radius:0;border:2px dashed #000;font-size:smaller}.download-button{display:inline-block;padding:.25rem .5rem;border-radius:0;border:2px dashed #000;font-size:smaller;text-decoration:none;color:inherit}.download-button:hover{background-color:var(--link-hover-color);color:#fff;transition:color .2s ease;font-weight:700;opacity:1}.menu li .resume-button{text-decoration:none;color:#fff;background-color:#000;border-radius:5px;line-height:1em;padding:8px 0 8px 10px;align-items:center;font-size:small;z-index:400}.portfolio-button{text-decoration:none;color:#fff;background-color:#000;border-radius:5px;line-height:1em;margin-right:10px;padding:4px 0 4px 10px;align-items:center;font-size:small;display:flex}.portfolio-icon{margin-left:3px;margin-right:4px}[class*=" icon-"].portfolio-icon::before,[class^=icon-].portfolio-icon::before{font-size:16px}[class*=" icon-"].tags-icon::before,[class^=icon-].tags-icon::before{font-size:16px}.navbar-icon{color:#000;margin-left:5px;margin-right:5px}.note-footer{grid-area:footer;background-color:var(--footer-bg-color);border-top:2px dashed var(--gray);margin-top:20px;padding-top:.8rem;display:flex;align-items:center;justify-content:space-between}.note-tags{padding:0}.note-tags a{display:block;padding-inline-start:10px;padding-inline-end:10px;font-size:14px;line-height:30px;text-decoration:none;background-color:var(--tag-bg);border:2px solid var(--tag-text);color:var(--tag-text);border-radius:10px;transition:transform .1s}.note-tags.mini a{display:block;padding-inline-start:10px;padding-inline-end:10px;font-size:14px;line-height:25px;text-decoration:none;background-color:var(--tag-bg);border:2px solid var(--tag-text);color:var(--tag-text);border-radius:6px;transition:transform .1s}.note-tags a:before{content:"#";margin-right:.25rem}.note-tags a:hover{transform:scale(1.05)}.note-tags sup{font-size:xx-small;vertical-align:super}.note-tags li{display:inline-block;padding-right:10px;padding-bottom:5px;padding-top:5px}.tag-yellow{background-color:#ffde69;border:2px solid #594600;color:#594600}.tag{display:inline-block;padding:.25rem .75rem;margin:1rem .5rem 0 0;font-size:1rem;font-family:Inter,sans-serif;line-height:130%;border-radius:.5rem;text-decoration:none;position:relative;top:0;transition:.35s}.anchor{float:left;margin-left:-1em;padding-right:.34em;vertical-align:middle;color:#000;visibility:hidden;background:0 0}figcaption{font-family:Inconsolata,monospace;font-style:normal;font-weight:700;font-size:13px;letter-spacing:.02em;line-height:1.6em;color:rgba(53,53,53,.8)}.images-row{display:flex;margin:20px -5px}.images-row picture{margin:0 5px}.images-row figure picture{margin:0}.images-row figure{margin:0 5px 20px 5px}.images-row img{display:inline-block;max-width:100%;width:auto;height:100%;border-radius:var(--image-border-radius)}li{margin:0;padding:0;font-family:Inconsolata,monospace;text-align:justify;font-style:normal;font-size:16px;letter-spacing:.02em;line-height:1.6em}p img{max-width:100%;border-radius:var(--image-border-radius)}p img[width][height]{height:100%}figure img[width][height]{height:100%}p img{display:block;margin-left:auto;margin-right:auto;border-style:none;margin-bottom:20px;margin-top:20px}.note-video{display:block;margin-left:auto;margin-right:auto;margin-top:30px;margin-bottom:30px}.blob-num{border-right:1px solid #ddd}.gist-meta a{color:#3b5998!important;font-weight:700;text-decoration:none}.gist-meta a:hover{text-decoration:underline!important}.original-marker{background:linear-gradient(104deg,rgba(130,255,173,0) .9%,#82ffad 2.4%,rgba(130,255,173,.5) 5.8%,rgba(130,255,173,.1) 93%,rgba(130,255,173,.7) 96%,rgba(130,255,1732,0) 98%),linear-gradient(183deg,rgba(130,255,173,0) 0,rgba(130,255,173,.3) 7.9%,rgba(130,255,173,0) 15%);padding:.1em .4em;-webkit-box-decoration-break:clone;margin:0;border-radius:7.5px;text-shadow:-12px 12px 9.8px rgba(130,255,173,.7),21px -18.1px 7.3px #fff,-18.1px -27.3px 30px #fff}mark2{margin:0 -.4em;padding:.1em .4em;border-radius:.8em .3em;background:0 0;background-image:linear-gradient(to right,rgba(255,225,0,.1),rgba(255,225,0,.7) 4%,rgba(255,225,0,.3));-webkit-box-decoration-break:clone;box-decoration-break:clone}figure{display:block;margin-left:auto;margin-right:auto;margin-top:30px;margin-bottom:30px}picture{display:flex;justify-content:center;margin:0}figcaption{display:flex;justify-content:center}#profile-picture{width:50px;height:50px;border-radius:9999px}.navbar-nav>.active{color:#282828;font-weight:700}.nav-title{color:#1b1b1b;text-decoration:none;padding-top:.5rem;padding-bottom:.5rem;padding-left:.75rem;padding-right:.75rem;border-radius:.25rem}.nav-title:hover{color:#000;background:#f4f4f4}.nav-title-active{color:#1571e4}summary{list-style:none;border:2px solid #000;padding:.75em 1em;border-radius:0;cursor:pointer;position:relative;padding-left:calc(1.75rem + .75rem + .75rem)}summary:before{position:absolute;top:50%;transform:translateY(-50%);left:.75rem;content:"‚Üì";width:1.75rem;height:1.75rem;background-color:#000;color:#fff;display:inline-flex;justify-content:center;align-items:center;flex-shrink:0}details[open] summary{background-color:#eee}details[open] summary:before{content:"‚Üë"}details div{border-left:2px solid #000;border-right:2px solid #000;border-bottom:2px solid #000;padding-left:1em;padding-right:1em}summary:hover{background-color:#eee}@font-face{font-family:icons;src:url('/assets/fonts/icons.woff2?7673508') format('woff2'),url('/assets/fonts/icons.woff?7673508') format('woff'),url('/assets/fonts/icons.svg?7673508#icons') format('svg');font-weight:400;font-style:normal;font-display:swap}.footer-icon{color:#bebebe}.footer-icon:hover{color:#3c3c3c}[class*=" icon-"]:before,[class^=icon-]:before{font-family:icons;font-style:normal;font-weight:400;display:inline-block;text-decoration:inherit;font-size:24px;width:1em;margin-right:.2em;text-align:center;font-variant:normal;text-transform:none;line-height:1em;margin-left:.2em;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.icon-tag:before{content:"\e935"}.icon-eye:before{content:"\e9ce"}.icon-arrow-up:before{content:"\ea3a"}.icon-twitter:before{content:"\ea96"}.icon-github:before{content:"\eab0"}.icon-linkedin:before{content:"\eac9"}@media only screen and (max-device-width:1920px){#navbar-mobile{display:none}#back-to-top-mobile{display:none}p img[width]{width:50%}figure img[width]{width:50%}}@media only screen and (max-device-width:576px){#navbar-mobile{display:flex}#navbar-desktop{display:none}#back-to-top-mobile{display:block}#back-to-top-desktop{display:none}p img[width]{width:100%}figure img[width]{width:100%}video[width]{width:100%}}@media (min-width:350px){.column-page,.note{grid-template-columns:auto 300px auto}.wide-column-page{grid-template-columns:auto 300px auto}}@media (min-width:450px){.column-page,.note{grid-template-columns:auto 400px auto}.wide-column-page{grid-template-columns:auto 400px auto}}@media (min-width:576px){.column-page,.note{grid-template-columns:auto 500px auto}.wide-column-page{grid-template-columns:auto 500px auto}}@media (min-width:768px){.column-page,.note{grid-template-columns:auto 500px auto}.wide-column-page{grid-template-columns:auto 750px auto}}@media (min-width:992px){.column-page,.note{grid-template-columns:auto 700px auto}.wide-column-page{grid-template-columns:auto 900px auto}}@media (min-width:1200px){.column-page,.note{grid-template-columns:auto 700px auto}.wide-column-page{grid-template-columns:auto 1150px auto}}@media (min-width:1400px){.column-page,.note{grid-template-columns:auto 700px auto}.wide-column-page{grid-template-columns:auto 1350px auto}}:root{--body-bg-color:#fcfcfc;--note-bg-color:#fcfcfc;--projects-page-bg-color:#fcfcfc;--scrollbar-bg-color:rgba(0, 0, 0, 0.15);--navbar-bg-color:#fefefe;--footer-bg-color:#fcfcfc;--content-size:800px;--link-hover-color:rgb(0, 0, 0);--marker-roundness:10px;--green:130,255,173;--orange:255,218,98;--blue:79,155,255;--red:255,98,124;--yellow:255,234,71;--gray:rgba(60, 60, 60, 0.7)}body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}.px-50{padding-left:.5rem;padding-right:.5rem}.px-75{padding-left:.75rem;padding-right:.75rem}.px-150{padding-left:1.5rem;padding-right:1.5rem}.py-50{padding-top:.5rem;padding-bottom:.5rem}.py-75{padding-top:.75rem;padding-bottom:.75rem}.rounded-25{border-radius:.25rem}.c-gray{color:#282828}.bg-gray-hover:hover{background:#f4f4f4}.no-underline{text-decoration:none}.align-right{text-align:right;list-style-position:inside}::selection{background-color:#e0e0e0}.fade-in{animation:fade-in .8s cubic-bezier(.165,.84,.44,1) both}@keyframes fade-in{0%{opacity:0}100%{opacity:1}}h1,h2,h3{padding-top:40px;padding-bottom:20px}h4{padding-top:15px;padding-bottom:5px;font-size:15px}.note-entry-header h3{padding-top:0}.note-entry-content h3{padding-bottom:0}.project-entry-content h3{padding-bottom:0}.note-content h1{text-align:center}.note-content h2{margin:0}.projects-page-content h2::before{content:"#";color:#cecece;margin:0 10px 0 0}.note-content h2::before{content:"#";color:#cecece;margin:0 10px 0 0}.note-content h3{padding-top:30px}.column-page-content h2::before{content:"#";color:#cecece;margin:0 10px 0 0}.note-content p{margin-bottom:10px;padding:0;font-family:Inconsolata,monospace;text-align:justify;font-style:normal;font-size:16px;letter-spacing:.02em;line-height:1.6em}p{-webkit-hyphens:auto;-ms-hyphens:auto;-moz-hyphens:auto;hyphens:auto}.note-content p a{text-decoration:none;border-bottom:2px dotted #000;opacity:1;color:#000;white-space:pre-wrap;white-space:-moz-pre-wrap;white-space:-pre-wrap;white-space:-o-pre-wrap;word-wrap:break-word}.note-content p a:hover{background-color:var(--link-hover-color);color:#fff;transition:color .2s ease;font-weight:700;opacity:1}mark.green{--marker-color:var(--green)}mark.blue{--marker-color:var(--blue)}mark.orange{--marker-color:var(--orange)}mark.red{--marker-color:var(--red)}mark.yellow{--marker-color:var(--yellow)}mark{padding:.1em 5px;margin-right:-5px;margin-left:-5px;border-radius:var(--marker-roundness);-webkit-box-decoration-break:clone;box-decoration-break:clone;background:linear-gradient(104deg,rgba(0,0,0,0) .9%,rgba(var(--marker-color),1.25) 2.4%,rgba(var(--marker-color),.5) 5.8%,rgba(var(--marker-color),.25) 93%,rgba(var(--marker-color),.7) 96%,rgba(0,0,0,0) 98%),linear-gradient(183deg,rgba(0,0,0,0) 0,rgba(var(--marker-color),.3) 7.9%,rgba(0,0,0,0) 15%)}blockquote{box-sizing:border-box;font-style:italic;color:#494949;background-color:rgba(235,236,237,.5);border-color:transparent;border-radius:3px;border-width:1px;border-style:solid;margin-top:10px;margin-bottom:10px;padding:8px 8px 8px 8px}.column-page-content blockquote p{margin:0;text-align:left}.katex-display .katex{padding-top:10px;padding-bottom:10px;border:2px dashed #cacaca;border-radius:5px}.katex-display>.katex{white-space:nowrap;text-align:initial}.katex{line-height:1.2;white-space:normal;text-indent:0}.projects{margin:0 auto;display:grid;grid-gap:1rem;grid-template-columns:repeat(auto-fill,minmax(200px,1fr))}.project-entry{position:relative;background:#fff;border-radius:10px;transition:transform .2s;border:1px solid #f0f0f0}.project-entry-image{border-radius:10px 10px 0 0;height:100px;object-fit:cover;width:100%}.project-entry:active{transform:scale(.95)}.project-entry-content{padding:15px}.project-entry-description{margin:8px 0;color:var(--gray);font-size:14px;line-height:1.6;overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:2}.project-entry-footer{color:var(--gray);font-size:12px}.project-entry-link{position:absolute;left:0;right:0;top:0;bottom:0}.project-image{border-radius:10px}.action-buttons{display:flex;justify-content:space-evenly}.action-button-link{position:absolute;left:0;right:0;top:0;bottom:0}.action-button:hover{transform:scale(1.02)}.column-page-content .action-button p{text-align:center;margin:0}.action-button{max-width:fit-content;width:100%;display:block;font-size:14px;line-height:30px;color:#fff;text-decoration:none;background:#000;border-radius:10px;transition:transform .1s;position:relative;padding:12px;margin-bottom:20px}.note-entry-content{position:relative;margin-bottom:20px;padding:15px;background:#fff;border-radius:10px;transition:transform .2s;border:1px solid #f0f0f0}.note-entry:active{transform:scale(.95)}.note-entry-description{margin:8px 0;color:var(--gray);font-size:14px;line-height:1.6;overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:2}.column-page-content .note-entry-description p{text-align:left}.column-page-content .note-entry-header h3{line-height:1.3em}.column-page-content p{margin-bottom:10px;font-family:Inconsolata,monospace;text-align:justify;font-style:normal;font-size:16px;letter-spacing:.02em;line-height:1.6em}.note-title{line-height:1.3em}.column-page-content p a{text-decoration:none;border-bottom:2px dotted #000;opacity:1;color:#000}.column-page-content p a:hover{background-color:var(--link-hover-color);color:#fff;transition:color .2s ease;font-weight:700;opacity:1}.devlog-entry-description p{font-family:Inter,serif}.devlog-entry-tags p{font-family:Inter,serif}.devlog-entry-tags{font-size:14px;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:2}.devlog-tags{padding:0}.devlog-tags p{display:block;padding-inline-start:10px;padding-inline-end:10px;font-size:14px;line-height:25px;text-decoration:none;background-color:var(--tag-bg);border:1.5px solid var(--tag-text);color:var(--tag-text);border-radius:5px}.devlog-tags p:before{content:"#";margin-right:.25rem}.devlog-tags li{display:inline-block;padding-right:10px;padding-bottom:5px;padding-top:15px}.devlog-entry-tags a:before{content:"#";margin-right:.25rem}.devlog-entry-footer{color:var(--gray);font-size:12px}.devlog-entry-link{position:absolute;left:0;right:0;top:0;bottom:0}.tags-icon{width:.2em;margin:0;padding:0}.devlog-entry-header h3{padding-top:0}.devlog-entry-content h3{padding-bottom:0}.devlog-entry{display:flex;border:1px solid #f0f0f0;justify-content:space-between;border-radius:10px;transition:transform .2s;background:#fff;overflow:hidden}.devlog-entry-content{position:relative;margin-bottom:20px;padding:15px}.devlog-entry-image{display:flex;height:150px;position:relative;align-items:center;justify-content:center}.devlog-entry-image img{display:block;height:100%}.devlog-entry-tags{text-align:center}.devlog-entry:active{transform:scale(.95)}.devlog-entry-description{margin:8px 0;color:var(--gray);font-size:14px;line-height:1.6;overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:2}.note-entry-description p{font-family:Inter,serif}.note-entry-footer{color:var(--gray);font-size:12px}.note-entry-link{position:absolute;left:0;right:0;top:0;bottom:0}.bold{font-weight:700}.timeline{margin-top:20px;margin-bottom:20px}.timeline-list{position:relative;padding-left:45px;list-style:none}.timeline-event p{position:relative;top:-5px;margin:0;text-align:left}.timeline-event .year{font-size:small;padding:0;margin:0;font-weight:700;color:#6e6e6e}.timeline-event{position:relative}.timeline-event.is-not-done{padding-bottom:30px}.timeline-event.is-done{padding-bottom:15px}.timeline-event:before{display:inline-block;content:'';position:absolute;left:-37px;height:100%;width:10px}.timeline-event::after{content:'';display:inline-block;position:absolute;top:0;left:-44px;width:12px;height:12px;border:2px solid #000;border-radius:50%;background-color:#fff}.timeline-event.is-not-done::before{border-left:3px dotted #000}.timeline-event.is-done:not(:last-child)::before{border-left:3px solid #000}.timeline-event.is-done::after{font-size:10px;border:2px solid #000;background-color:#000}.home-header{display:flex;align-items:center;padding-top:20px;padding-bottom:20px}.home-header h2{padding:0;margin:0 0 0 10px;text-align:left}.home-header img{width:3.5rem;height:3.5rem;border-radius:100%;flex-grow:0;flex-shrink:0}.back-to-top-mobile{position:absolute;top:116vh;right:0;bottom:0}.back-to-top-mobile a{padding:.5rem;position:-webkit-sticky;position:sticky;top:91vh;text-decoration:none;display:inline-block;text-align:center;transition:top .4s ease 0s;color:#000;background-color:#fff;border-radius:.25rem;box-shadow:0 8px 15px rgba(0,0,0,.1)}.back-to-top-desktop{position:absolute;top:120vh;bottom:0;right:-100px}.back-to-top-desktop a{padding:.5rem;position:-webkit-sticky;position:sticky;top:91vh;text-decoration:none;display:inline-block;text-align:center;transition:top .4s ease 0s;color:#3c3c3c;background-color:#fff;border-radius:.25rem;box-shadow:0 8px 15px rgba(0,0,0,.1)}.back-to-top-desktop a:hover{top:85vh;color:#aaa}::-webkit-scrollbar{width:22px}::-webkit-scrollbar-track{background:0 0}::-webkit-scrollbar-thumb{background:var(--scrollbar-bg-color);border:5px solid var(--body-bg-color);border-radius:8px}::-webkit-scrollbar-thumb:hover{background:rgba(0,0,0,.25)}code[class*=language-],pre[class*=language-]{color:#d6deeb;font-family:Consolas,Monaco,"Andale Mono","Ubuntu Mono",monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;font-size:.9em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{text-shadow:none;background:rgba(29,59,83,.99)}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{text-shadow:none;background:rgba(29,59,83,.99)}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{padding:1em;margin:1.25em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{color:#fff;background:#011627;border-radius:4px}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.prolog{color:#637777;font-style:italic}.token.punctuation{color:#c792ea}.namespace{color:#b2ccd6}.token.deleted{color:rgba(239,83,80,.56);font-style:italic}.token.property,.token.symbol{color:#80cbc4}.token.keyword,.token.operator,.token.tag{color:#7fdbca}.token.boolean{color:#ff5874}.token.number{color:#f78c6c}.token.builtin,.token.char,.token.constant,.token.function{color:#82aaff}.token.doctype,.token.selector{color:#c792ea;font-style:italic}.token.attr-name,.token.inserted{color:#addb67;font-style:italic}.language-css .token.string,.style .token.string,.token.entity,.token.string,.token.url{color:#addb67}.token.atrule,.token.attr-value,.token.class-name{color:#ffcb8b}.token.important,.token.regex,.token.variable{color:#d6deeb}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}pre::-webkit-scrollbar-thumb{background:#6e6e6e;border:5px solid;border-radius:8px;border-color:#011627}pre::-webkit-scrollbar-thumb:hover{background:#969696}</style>


<!-- Request the stylesheet asynchronously. The onload attribute allows the CSS to be processed when it finishes loading. The noscript works as a fallback for browsers that don't execute JS. -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB" crossorigin="anonymous">

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js" integrity="sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p" crossorigin="anonymous"></script>

    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>



<!-- ICONS -->
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22><text y=%2224%22 font-size=%2224%22>üñçÔ∏è</text></svg>">
<link rel="preload" as="font" href="/assets/fonts/icons.woff2?7673508" type="font/woff2" crossorigin="crossorigin"/>

<!-- INLINED GOOGLE FONTS -->
<link rel="preconnect" as="font" href="https://fonts.gstatic.com">
<style>
  body,
  h1,
  h2,
  h3,
  h5 {
    font-family: 'Inter', serif;
  }
</style>
<style>
  /* latin */
  @font-face {
    font-family: 'Inter';
    font-style: normal;
    font-weight: 700;
    font-display: swap;
    src: url("https://fonts.gstatic.com/s/inter/v3/UcC73FwrK3iLTeHuS_fvQtMwCp50KnMa1ZL7.woff2") format('woff2');
    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
  }
</style>
<!-- <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">-->

<!-- GOOGLE ANALYTICS -->

  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-137365487-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
      dataLayer.push(arguments);
    }
    gtag('js', new Date());
    gtag('config', 'UA-137365487-1');
  </script>

    </head>

    <!-- BODY -->
    <body class="fade-in">
            
<style>
    :root {
        --marker-color: var(--yellow);
    }
</style>

<!-- NAV BAR -->
<header id="navbar-desktop" class="py-75 px-150">
  <!-- <a href="/" aria-label="Back to home page."> <span class="icon-menu px-75 py-75 rounded-25 c-gray bg-gray-hover"></span></a> -->

  <a href="/" aria-label="Back to home page.">
    <img src="/assets/img/icons/letter_a.svg" style="width: 32px; height: 32px;" alt="Website icon" class="navbar-icon"></a>

  <div class="navbar-nav">

  <!--  <a href="/projects" title="My projects" aria-label="My projects." class=" nav-title">Projects</a>-->

<a href="/" aria-label="Home page." class=" nav-title">Home</a>

    <a href="/notes" aria-label="All notes." class=" nav-title">Notes</a>


    <!--<a href="/devlogs" aria-label="My devlogs." class=" nav-title">Devlogs</a>-->

    <!--<a href="/projects" aria-label="My porworktfolio." class=" nav-title">Projects</a>
    -->
    <a href="/contact" aria-label="Contact me." class=" nav-title">Contact</a>

  </div>
</header>

<!-- https://cutcodedown.com/tutorial/mobileMenu-->
<!--https://medium.com/@heyoka/responsive-pure-css-off-canvas-hamburger-menu-aebc8d11d793-->
<header id="navbar-mobile">
  <a href="/" aria-label="Back to home page.">
    <img src="/assets/img/icons/letter_a.svg" style="width: 32px; height: 32px;" alt="Website icon" class="navbar-icon"></a>

  <div style="vertical-align: middle; display: flex; align-items: center;">
 <!--   <a class="portfolio-button" href="/projects">My work<span class="icon-eye portfolio-icon"></span></a>-->

   <label for="toggle">
      <span class="icon-menu navbar-icon"></span></label>
  

  </div>

   


</header>

  <input type="checkbox" id="toggle"/>
    <div id="menu" style="" class="menu">
      <ul>
         <!--  <li>
          <a href="/projects">Projects</a>
        </li>-->
        <li>
          <a href="/">Home</a>
        </li>
        <li>
          <a href="/notes">Notes</a>
        </li>
      
        <li>
          <a href="/contact">Contact</a>
        </li>
        <li>
          <a class="resume-button" href="/downloads/documents/resume_alexander_ameye.pdf" download rel="nofollow">Resume<span class="icon-eye portfolio-icon"></span></a>
        </li>
      </ul>
    </div>

<div class="note column-page">
    <div class="note-content column-page-content">
        <h1 class="note-title">üñçÔ∏è
            5 ways to draw an outline</h1>

        
          <div class="reading-time">18-minute read</div><h2>Introduction</h2>
<p>Rendering outlines is a technique that is often used in games either for <mark>aesthetic</mark> reasons or for supporting <mark>gameplay</mark> by using it for highlights and selections around an object. For example in the game Sable, outlines are used to create a comic-book-like style. In The Last of Us, outlines are used to highlight enemies when the player goes into stealth mode.</p>
<div class="images-row">
<figure><picture><source type="image/webp" srcset="introduction/sable.png-300w.webp 300w, introduction/sable.png-400w.webp 400w, introduction/sable.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="introduction/sable.png-300w.jpeg 300w, introduction/sable.png-400w.jpeg 400w, introduction/sable.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Sable." style="width:100%;" loading="lazy" decoding="async" src="introduction/sable.png-300w.jpeg" width="600" height="309"></picture><figcaption>Sable.</figcaption></figure>
<figure><picture><source type="image/webp" srcset="introduction/last-of-us.png-300w.webp 300w, introduction/last-of-us.png-400w.webp 400w, introduction/last-of-us.png-600w.webp 600w" sizes="(min-width: 640px) 50vw, 100vw"><source type="image/jpeg" srcset="introduction/last-of-us.png-300w.jpeg 300w, introduction/last-of-us.png-400w.jpeg 400w, introduction/last-of-us.png-600w.jpeg 600w" sizes="(min-width: 640px) 50vw, 100vw"><img class="note-image" alt="The Last of Us." style="width:100%;" loading="lazy" decoding="async" src="introduction/last-of-us.png-300w.jpeg" width="600" height="337"></picture><figcaption>The Last of Us.</figcaption></figure>
</div>
<p>In this post, I will discuss 5 techniques for rendering an outline around an object.</p>
<h2>Rim Effects</h2>
<p><picture><source type="image/webp" srcset="rim-effect/final.png-300w.webp 300w, rim-effect/final.png-400w.webp 400w, rim-effect/final.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="rim-effect/final.png-300w.jpeg 300w, rim-effect/final.png-400w.jpeg 400w, rim-effect/final.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Rim effect outline." style="width:100%;" loading="lazy" decoding="async" src="rim-effect/final.png-300w.jpeg" width="600" height="235"></picture></p>
<h3>Technique</h3>
<p>One of the most basic outline effects can be achieved by using a so called <mark>fresnel effect</mark> which can be used to render an outline on the rim/edge of an object. The fresnel effect describes the reflection/transmission of light when falling onto a transparent surface. However, when using it for rendering outlines, this physical meaning of the effect is not important. The following formula is used to form the outline.</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mi>u</mi><mi>t</mi><mo>=</mo><mi>p</mi><mi>o</mi><mi>w</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mn>1.0</mn><mo>‚àí</mo><mi>s</mi><mi>a</mi><mi>t</mi><mi>u</mi><mi>r</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo stretchy="false">(</mo><mi>d</mi><mi>o</mi><mi>t</mi><mo stretchy="false">(</mo><mi>N</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Out = pow((1.0 - saturate(dot(N, V))), P)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">((</span><span class="mord">1.0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">‚àí</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)))</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span></span></p>
<p>The formula takes the dot product between the normalized normal vector <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> and the normalized view direction <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>. Then, this gets exponentiated with a power <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>. It is important to note that this is only an approximation of the fresnel effect, but it works well for our outlines.</p>
<p><picture><source type="image/webp" srcset="rim-effect/fresnel.png-300w.webp 300w, rim-effect/fresnel.png-400w.webp 400w, rim-effect/fresnel.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="rim-effect/fresnel.png-300w.jpeg 300w, rim-effect/fresnel.png-400w.jpeg 400w, rim-effect/fresnel.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Fresnel effect." style="width:100%;" loading="lazy" decoding="async" src="rim-effect/fresnel.png-300w.jpeg" width="600" height="237"></picture></p>
<p>When putting this fresnel-based outline on a sphere, you see that when we approach the grazing angle (the edge/rim of the object), the effect gets stronger.</p>
<h3>Implementation</h3>
<p>For this approach, the objects that need to have an outline get rendered using a custom shader. This shader implements the fresnel effect and allows us to set the width, power, softness and color of the outline.</p>
<pre class="language-hlsl"><code class="language-hlsl"><span class="token keyword">float</span> edge1 <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> _OutlineWidth<span class="token punctuation">;</span><br><span class="token keyword">float</span> edge2 <span class="token operator">=</span> edge1 <span class="token operator">+</span> _OutlineSoftness<span class="token punctuation">;</span><br><span class="token keyword">float</span> fresnel <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> <span class="token function">saturate</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>normalWS<span class="token punctuation">,</span> viewWS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> _OutlinePower<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">return</span> <span class="token function">lerp</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">smoothstep</span><span class="token punctuation">(</span>edge1<span class="token punctuation">,</span> edge2<span class="token punctuation">,</span> fresnel<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">step</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> edge1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> _OutlineColor<span class="token punctuation">;</span></code></pre>
<p>The technique produces an outline that is always an <mark>inner line</mark> and is not visible outside of the object and so maybe shouldn't even be called an outline. By controlling the width, power and softness of the outline, it is possible to create hard lines or a more soft/glowy effect.</p>
<div class="images-row">
<picture><source type="image/webp" srcset="rim-effect/hard-outline.png-300w.webp 300w, rim-effect/hard-outline.png-400w.webp 400w, rim-effect/hard-outline.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="rim-effect/hard-outline.png-300w.jpeg 300w, rim-effect/hard-outline.png-400w.jpeg 400w, rim-effect/hard-outline.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Rim effect outline (hard)." style="width:100%;" loading="lazy" decoding="async" src="rim-effect/hard-outline.png-300w.jpeg" width="600" height="600"></picture>
<picture><source type="image/webp" srcset="rim-effect/soft-outline.png-300w.webp 300w, rim-effect/soft-outline.png-400w.webp 400w, rim-effect/soft-outline.png-600w.webp 600w" sizes="(min-width: 640px) 50vw, 100vw"><source type="image/jpeg" srcset="rim-effect/soft-outline.png-300w.jpeg 300w, rim-effect/soft-outline.png-400w.jpeg 400w, rim-effect/soft-outline.png-600w.jpeg 600w" sizes="(min-width: 640px) 50vw, 100vw"><img class="note-image" alt="Rim effect outline (soft)." style="width:100%;" loading="lazy" decoding="async" src="rim-effect/soft-outline.png-300w.jpeg" width="600" height="600"></picture>
</div>
<p>Characteristic for this approach is that it works well for objects like spheres and capsules with smooth and round edges, but it breaks down for objects like cubes or more complex models that have sharp edges.</p>
<div class="images-row">
<picture><source type="image/webp" srcset="rim-effect/cube.png-300w.webp 300w, rim-effect/cube.png-400w.webp 400w, rim-effect/cube.png-600w.webp 600w" sizes="(min-width: 640px) 50vw, 100vw"><source type="image/jpeg" srcset="rim-effect/cube.png-300w.jpeg 300w, rim-effect/cube.png-400w.jpeg 400w, rim-effect/cube.png-600w.jpeg 600w" sizes="(min-width: 640px) 50vw, 100vw"><img class="note-image" alt="Rim effect outline (cube)." style="width:100%;" loading="lazy" decoding="async" src="rim-effect/cube.png-300w.jpeg" width="600" height="600"></picture>
<picture><source type="image/webp" srcset="rim-effect/complex-model.png-300w.webp 300w, rim-effect/complex-model.png-400w.webp 400w, rim-effect/complex-model.png-600w.webp 600w" sizes="(min-width: 640px) 50vw, 100vw"><source type="image/jpeg" srcset="rim-effect/complex-model.png-300w.jpeg 300w, rim-effect/complex-model.png-400w.jpeg 400w, rim-effect/complex-model.png-600w.jpeg 600w" sizes="(min-width: 640px) 50vw, 100vw"><img class="note-image" alt="Rim effect outline (complex model)." style="width:100%;" loading="lazy" decoding="async" src="rim-effect/complex-model.png-300w.jpeg" width="600" height="600"></picture>
</div>
<p>For a cube for example, the outline will look really bad and not even resemble an outline. For a more complex model, you will have the issue of getting lots of uneven line widths, although the overall outline effect can look alright.</p>
<blockquote>
<p><strong>üí¨ Rim effect</strong> outlines are simple but only work well on spherical objects.</p>
</blockquote>
<h2>Vertex Extrusion</h2>
<p><picture><source type="image/webp" srcset="vertex-extrusion/final.png-300w.webp 300w, vertex-extrusion/final.png-400w.webp 400w, vertex-extrusion/final.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="vertex-extrusion/final.png-300w.jpeg 300w, vertex-extrusion/final.png-400w.jpeg 400w, vertex-extrusion/final.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Vertex extrusion outline." style="width:100%;" loading="lazy" decoding="async" src="vertex-extrusion/final.png-300w.jpeg" width="600" height="238"></picture></p>
<h3>Technique</h3>
<p>The second technique uses a <mark>re-rendered/duplicate</mark> version of the original object/mesh to form the outline. This duplicate object gets shown <mark>behind</mark> the original object and its vertices get extruded in order to make the duplicate object larger than the original one. The duplicate object is usually just rendered with a flat color.</p>
<h3>Extrusion direction</h3>
<p>In order to make the duplicate mesh larger, we need to change the positions of its vertices. We will be moving the vertices a certain <mark>distance</mark> along a certain <mark>direction</mark>. The first step is to pick this direction.</p>
<h4>1. Vertex position</h4>
<p>The <mark>first method</mark> to enlarge the mesh is to simply scale it up. This is done by moving each vertex position along the vertex position. This may sound weird but the vertex position in local space, can be seen as a vector between the center of the object and the vertex position itself and so we can move the original vertex position along that vector. For the distance, we use a width parameter.</p>
<pre class="language-hlsl"><code class="language-hlsl"><span class="token comment">// Move vertex along vertex position in object space.</span><br>positionOS <span class="token operator">+=</span> positionOS <span class="token operator">*</span> width<span class="token punctuation">;</span></code></pre>
<p>Doing this just kind of inflates the mesh.</p>
<p><picture><source type="image/webp" srcset="vertex-extrusion/object-space-vertex-position.png-300w.webp 300w, vertex-extrusion/object-space-vertex-position.png-400w.webp 400w, vertex-extrusion/object-space-vertex-position.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="vertex-extrusion/object-space-vertex-position.png-300w.jpeg 300w, vertex-extrusion/object-space-vertex-position.png-400w.jpeg 400w, vertex-extrusion/object-space-vertex-position.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Move along vertex position in object space." style="width:100%;" loading="lazy" decoding="async" src="vertex-extrusion/object-space-vertex-position.png-300w.jpeg" width="600" height="269"></picture></p>
<p>For a sphere, all of the vertices have the same distance from the center point of the object and so they all get moved an equal amount. However, for other objects, these distances may vary and so vertices that are distanced further away from the center of the object, will get moved more. To fix this, you can normalize the vector along which the movement occurs.</p>
<pre class="language-hlsl"><code class="language-hlsl"><span class="token comment">// Move vertex along normalized vertex position in object space.</span><br>positionOS <span class="token operator">+=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>positionOS<span class="token punctuation">)</span> <span class="token operator">*</span> width<span class="token punctuation">;</span></code></pre>
<p>The result is that now all the vertices get moved an equal distance in object space, usually resulting in an outline that looks more equal-width.</p>
<p><picture><source type="image/webp" srcset="vertex-extrusion/object-space-normalized-vertex-position.png-300w.webp 300w, vertex-extrusion/object-space-normalized-vertex-position.png-400w.webp 400w, vertex-extrusion/object-space-normalized-vertex-position.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="vertex-extrusion/object-space-normalized-vertex-position.png-300w.jpeg 300w, vertex-extrusion/object-space-normalized-vertex-position.png-400w.jpeg 400w, vertex-extrusion/object-space-normalized-vertex-position.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Move along normalized vertex position in object space." style="width:100%;" loading="lazy" decoding="async" src="vertex-extrusion/object-space-normalized-vertex-position.png-300w.jpeg" width="600" height="270"></picture></p>
<p>However, due to working in object space, the outline still isn't a perfect equal-width outline. We will address this later.</p>
<h4>2. Normal vector</h4>
<p>A <mark>second method</mark> is to move the vertices along their normal vector.</p>
<pre class="language-hlsl"><code class="language-hlsl"><span class="token comment">// Move vertex along normal vector in object space.</span><br>positionOS <span class="token operator">+=</span> normalOS <span class="token operator">*</span> width<span class="token punctuation">;</span></code></pre>
<p>The result is a pretty nice-looking outline for objects with smooth corners such as spheres and capsules. We're still working in object space so again, the outline isn't a perfect equal-width outline.</p>
<p><picture><source type="image/webp" srcset="vertex-extrusion/object-space-normal-vector.png-300w.webp 300w, vertex-extrusion/object-space-normal-vector.png-400w.webp 400w, vertex-extrusion/object-space-normal-vector.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="vertex-extrusion/object-space-normal-vector.png-300w.jpeg 300w, vertex-extrusion/object-space-normal-vector.png-400w.jpeg 400w, vertex-extrusion/object-space-normal-vector.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Move along normal vector in object space." style="width:100%;" loading="lazy" decoding="async" src="vertex-extrusion/object-space-normal-vector.png-300w.jpeg" width="600" height="270"></picture></p>
<p>For objects with sharper corners such as cubes, you will get visible gaps in the outline. Any model with sharp angles will have these kind of artifacts.</p>
<p><picture><source type="image/webp" srcset="vertex-extrusion/exploded-cube.png-300w.webp 300w, vertex-extrusion/exploded-cube.png-400w.webp 400w, vertex-extrusion/exploded-cube.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="vertex-extrusion/exploded-cube.png-300w.jpeg 300w, vertex-extrusion/exploded-cube.png-400w.jpeg 400w, vertex-extrusion/exploded-cube.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Outline gaps on objects with sharp corners." style="width:;" loading="lazy" decoding="async" src="vertex-extrusion/exploded-cube.png-300w.jpeg" width="600" height="556"></picture></p>
<p>This can be resolved by using custom-authored normals, addressed in the next method.</p>
<h4>3. Vertex color</h4>
<p>A <mark>third method</mark> is to move the vertices along their vertex color. The logic behind this is that you can generate custom normals and store those in the vertex color channels of the mesh. For example you could bake spherical (smooth) normals into vertex colors and use those for a cube mesh.</p>
<pre class="language-hlsl"><code class="language-hlsl"><span class="token comment">// Move vertex along normal vector in object space.</span><br>positionOS <span class="token operator">+=</span> vertexColor <span class="token operator">*</span> width<span class="token punctuation">;</span></code></pre>
<p>You can see the the outline around the cube looks much better when using custom normals.</p>
<div class="images-row">
<picture><source type="image/webp" srcset="vertex-extrusion/normal-vector.png-300w.webp 300w, vertex-extrusion/normal-vector.png-400w.webp 400w, vertex-extrusion/normal-vector.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="vertex-extrusion/normal-vector.png-300w.jpeg 300w, vertex-extrusion/normal-vector.png-400w.jpeg 400w, vertex-extrusion/normal-vector.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline." style="width:100%;" loading="lazy" decoding="async" src="vertex-extrusion/normal-vector.png-300w.jpeg" width="600" height="600"></picture>
<picture><source type="image/webp" srcset="vertex-extrusion/vertex-color.png-300w.webp 300w, vertex-extrusion/vertex-color.png-400w.webp 400w, vertex-extrusion/vertex-color.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="vertex-extrusion/vertex-color.png-300w.jpeg 300w, vertex-extrusion/vertex-color.png-400w.jpeg 400w, vertex-extrusion/vertex-color.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline." style="width:100%;" loading="lazy" decoding="async" src="vertex-extrusion/vertex-color.png-300w.jpeg" width="600" height="600"></picture>
</div>
<p>This method can avoid artifacts with models that have sharp edges but the big downside is the manual setup involved since you need to generate custom normals for your mesh, although this process can be automated using a script that bakes the normals.</p>
<h3>Extrusion space</h3>
<p>Once we have decided the direction along which we want to move the vertices, we need to choose in which coordinate space this extrusion should happen. During the vertex stage of our shader, the coordinates of the vertices start out being defined in object space and end up being transformed to clip space. This is done by applying the <mark>MVP (model/view/projection) matrix</mark>. Throughout the whole rendering pipeline, the coordinates of the vertices go through these spaces.</p>
<blockquote>
<p><strong>1.</strong> üì¶ object/model/local space</p>
</blockquote>
<blockquote>
<p><strong>2.</strong> üåç world space</p>
</blockquote>
<blockquote>
<p><strong>3.</strong> üì∑ camera/eye/view space</p>
</blockquote>
<blockquote>
<p><strong>4.</strong> ‚úÇÔ∏è (homogeneous) clip space</p>
</blockquote>
<blockquote>
<p><strong>5.</strong> üñ•Ô∏è screen space</p>
</blockquote>
<blockquote>
<p><strong>6.</strong> üñºÔ∏è viewport/window space</p>
</blockquote>
<p>The significance of these coordinate spaces for our outlines will be explained below. For more info, you can read my note on <a href="/notes/spaces-and-transformations" target="_blank" rel="noopener noreferrer">spaces and transformations</a>[coming soon].</p>
<h4>Object space</h4>
<p>The <mark>first method</mark> is to translate the vertices in object space.</p>
<pre class="language-hlsl"><code class="language-hlsl"><span class="token comment">// Move vertex along vertex position in object space.</span><br>IN<span class="token punctuation">.</span>positionOS<span class="token punctuation">.</span>xyz <span class="token operator">+=</span> IN<span class="token punctuation">.</span>positionOS<span class="token punctuation">.</span>xyz <span class="token operator">*</span> width<span class="token punctuation">;</span></code></pre>
<p>There are 2 big issues with doing the outline in object space. This is because when working in object space, the MVP transformations are yet to be applied. These transformations will alter the shape of the outline, distorting it in the process. The issues are as follows:</p>
<ol>
<li>
<p><mark>Scaling</mark> of the outline</p>
<p>-&gt; when going from object space to world space (applying model matrix M)</p>
</li>
<li>
<p><mark>Foreshortening</mark></p>
<p>-&gt; due to the perspective divide happening when going from clip space to screen space</p>
</li>
</ol>
<p><picture><source type="image/webp" srcset="vertex-extrusion/foreshortening.png-300w.webp 300w, vertex-extrusion/foreshortening.png-400w.webp 400w, vertex-extrusion/foreshortening.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="vertex-extrusion/foreshortening.png-300w.jpeg 300w, vertex-extrusion/foreshortening.png-400w.jpeg 400w, vertex-extrusion/foreshortening.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline." style="width:;" loading="lazy" decoding="async" src="vertex-extrusion/foreshortening.png-300w.jpeg" width="600" height="496"></picture></p>
<p>Another consideration is that when translating the vertices in object space, this is done in a 3D space. This means that some translations will be done directly towards or away from the camera, not contributing to the apparent-width of the outline. Instead of using object-space units, it might be better to be able to control the outline width in terms of screen-space pixels.</p>
<h4>Clip space</h4>
<p>A <mark>second method</mark> is to perform the translations of the vertices in clip space.</p>
<pre class="language-hlsl"><code class="language-hlsl"><span class="token comment">// Transform vertex from object space to clip space.</span><br>OUT<span class="token punctuation">.</span>positionHCS <span class="token operator">=</span> <span class="token function">TransformObjectToHClip</span><span class="token punctuation">(</span>IN<span class="token punctuation">.</span>positionOS<span class="token punctuation">.</span>xyz<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// Transform normal vector from object space to clip space.</span><br><span class="token keyword">float3</span> normalHCS <span class="token operator">=</span> <span class="token function">mul</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float3x3</span><span class="token punctuation">)</span>UNITY_MATRIX_VP<span class="token punctuation">,</span> <span class="token function">mul</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float3x3</span><span class="token punctuation">)</span>UNITY_MATRIX_M<span class="token punctuation">,</span> IN<span class="token punctuation">.</span>normalOS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// Move vertex along normal vector in clip space.</span><br>OUT<span class="token punctuation">.</span>positionHCS<span class="token punctuation">.</span>xy <span class="token operator">+=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>normalHCS<span class="token punctuation">.</span>xy<span class="token punctuation">)</span> <span class="token operator">/</span> _ScreenParams<span class="token punctuation">.</span>xy <span class="token operator">*</span> OUT<span class="token punctuation">.</span>positionHCS<span class="token punctuation">.</span>w <span class="token operator">*</span> width <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span></code></pre>
<p>As a first step, the vertex position and normal vector are both transformed from <mark>object space to clip space</mark>. As a second step, the vertex gets translated along its normal vector. Since we are working in a 2D space now, <mark>only the x and y</mark> coordinates of the vertex positions get altered. The offset gets divided by the width and height of the screen to account for the <mark>aspect ratio</mark> of the screen. Then, the offset gets multiplied by the w component of the clip space vertex position. This is done because in the next stage, the clip space coordinates will be converted to screen space coordinates with a so-called <mark>perspective divide</mark> which will divide the clip space x/y/z coordinates by the clip space w coordinate. Since we want to end up with the same outline after this transformation to screen space, we pre-multiply by this clip space w coordinate so that the perspective divide will have no net effect on the outline. Finally, the offset gets multiplied by our desired outline width and a factor 2 so that a width unit 1 will correspond with exactly 1 pixel on the screen.</p>
<p><em>Phew!</em></p>
<p>I recommend reading this post on <a href="https://www.videopoetics.com/tutorials/pixel-perfect-outline-shaders-unity/#working-in-clip-space" target="_blank" rel="noopener noreferrer">creating an outline in clip space</a>. Having something explained in different ways is always useful.</p>
<p>The result of this whole process is a very clean outline. Since we're working in clip space, the outline is equal-width, extending the same amount (visually) around the object.</p>
<p><picture><source type="image/webp" srcset="vertex-extrusion/clip-space-normal-vector.png-300w.webp 300w, vertex-extrusion/clip-space-normal-vector.png-400w.webp 400w, vertex-extrusion/clip-space-normal-vector.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="vertex-extrusion/clip-space-normal-vector.png-300w.jpeg 300w, vertex-extrusion/clip-space-normal-vector.png-400w.jpeg 400w, vertex-extrusion/clip-space-normal-vector.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Move along normal vector in clip space." style="width:100%;" loading="lazy" decoding="async" src="vertex-extrusion/clip-space-normal-vector.png-300w.jpeg" width="600" height="220"></picture></p>
<p>Still, (if not using custom-authored normals) the method has issues with meshes that have sharp-corners, resulting in gaps in the outline. This will be apparent in meshes that are more complex. Also, if the normals of the mesh are not set up correctly and some of them are facing the wrong way, the vertices of the outline will be moved in the opposite direction, resulting in gaps in the outline. This method being dependent on the normal vectors of the mesh is the most important downside. This is visible for the mesh in the image below.</p>
<p><picture><source type="image/webp" srcset="vertex-extrusion/clip-space-normal-vector-complex-model.png-300w.webp 300w, vertex-extrusion/clip-space-normal-vector-complex-model.png-400w.webp 400w, vertex-extrusion/clip-space-normal-vector-complex-model.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="vertex-extrusion/clip-space-normal-vector-complex-model.png-300w.jpeg 300w, vertex-extrusion/clip-space-normal-vector-complex-model.png-400w.jpeg 400w, vertex-extrusion/clip-space-normal-vector-complex-model.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Move along normal vector in clip space." style="width:100%;" loading="lazy" decoding="async" src="vertex-extrusion/clip-space-normal-vector-complex-model.png-300w.jpeg" width="600" height="258"></picture></p>
<h3>Masking</h3>
<p>The duplicate mesh should be rendered so that only the outline sticking out is visible. The most common solution for this is to <mark>cull the front-facing geometry</mark> of the duplicated mesh, using the backfaces of the geometry to form the outline. A depth test of <mark>less than or equal to</mark> is used to make sure the backfaces only show up where the outlines should go.</p>
<p><picture><source type="image/webp" srcset="vertex-extrusion/cull-front.png-300w.webp 300w, vertex-extrusion/cull-front.png-400w.webp 400w, vertex-extrusion/cull-front.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="vertex-extrusion/cull-front.png-300w.jpeg 300w, vertex-extrusion/cull-front.png-400w.jpeg 400w, vertex-extrusion/cull-front.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Cull front." style="width:;" loading="lazy" decoding="async" src="vertex-extrusion/cull-front.png-300w.jpeg" width="600" height="875"></picture></p>
<p>Another option is to use a <mark>stencil mask</mark> to prevent the duplicate mesh from showing up in front of the original mesh. When using this stencil mask method, no culling is needed. One side-effect is that there will be absolutely <mark>no inner lines</mark> on the inside of the object and if two objects overlap, the outline will also only be visible around those 2 objects.</p>
<p><picture><source type="image/webp" srcset="vertex-extrusion/stencil-mask.png-300w.webp 300w, vertex-extrusion/stencil-mask.png-400w.webp 400w, vertex-extrusion/stencil-mask.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="vertex-extrusion/stencil-mask.png-300w.jpeg 300w, vertex-extrusion/stencil-mask.png-400w.jpeg 400w, vertex-extrusion/stencil-mask.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Stencil mask." style="width:;" loading="lazy" decoding="async" src="vertex-extrusion/stencil-mask.png-300w.jpeg" width="600" height="875"></picture></p>
<blockquote>
<p><strong>üí¨ Vertex extrusion</strong> outlines are simple and look good when done in clip space. There are issues with sharp corners but these can be mitigated by using custom normals, which do require some extra setup.</p>
</blockquote>
<h2>Blurred Buffer</h2>
<p><picture><source type="image/webp" srcset="blurred-buffer/final.png-300w.webp 300w, blurred-buffer/final.png-400w.webp 400w, blurred-buffer/final.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="blurred-buffer/final.png-300w.jpeg 300w, blurred-buffer/final.png-400w.jpeg 400w, blurred-buffer/final.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline." style="width:100%;" loading="lazy" decoding="async" src="blurred-buffer/final.png-300w.jpeg" width="600" height="212"></picture></p>
<h3>Technique</h3>
<p>A third method to render an outline is by using something that I call a <mark>blurred buffer</mark>. For this technique, the silhouette of an object gets rendered to a buffer. This silhouette buffer is then blurred which expands the silhouette which is then used to render the outline.</p>
<h3>1. Silhouette Buffer</h3>
<p>The first step of this technique is creating the silhouette buffer. For this, each object gets rendered to a texture using a shader that outputs a plain color.</p>
<div class="images-row">
<picture><source type="image/webp" srcset="blurred-buffer/silhouette-colored.png-300w.webp 300w, blurred-buffer/silhouette-colored.png-400w.webp 400w, blurred-buffer/silhouette-colored.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="blurred-buffer/silhouette-colored.png-300w.jpeg 300w, blurred-buffer/silhouette-colored.png-400w.jpeg 400w, blurred-buffer/silhouette-colored.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline." style="width:100%;" loading="lazy" decoding="async" src="blurred-buffer/silhouette-colored.png-300w.jpeg" width="600" height="337"></picture>
<picture><source type="image/webp" srcset="blurred-buffer/silhouette-white.png-300w.webp 300w, blurred-buffer/silhouette-white.png-400w.webp 400w, blurred-buffer/silhouette-white.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="blurred-buffer/silhouette-white.png-300w.jpeg 300w, blurred-buffer/silhouette-white.png-400w.jpeg 400w, blurred-buffer/silhouette-white.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline." style="width:100%;" loading="lazy" decoding="async" src="blurred-buffer/silhouette-white.png-300w.jpeg" width="600" height="337"></picture>
</div>
<p>You can use the color white for all silhouettes, allowing you to choose a single color for all outlines at the end by multiplying with the desired outline color. Alternatively, you can render each object silhouette with a specific color if you want each object to have a different colored outline.</p>
<h3>2. Blur Pass</h3>
<p>The blur pass is used for expanding the silhouette buffer. This is usually done using a box blur or gaussian blur. To improve performance, the silhouette buffer can be <mark>scaled down</mark> before blurring. This is advantageous because blur passes can be expensive, having to process multiple pixels per pixel since they work by taking a (weighted) average of the pixels surrounding a given pixel.</p>
<p><picture><source type="image/webp" srcset="blurred-buffer/downscale.png-300w.webp 300w, blurred-buffer/downscale.png-400w.webp 400w, blurred-buffer/downscale.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="blurred-buffer/downscale.png-300w.jpeg 300w, blurred-buffer/downscale.png-400w.jpeg 400w, blurred-buffer/downscale.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline." style="width:;" loading="lazy" decoding="async" src="blurred-buffer/downscale.png-300w.jpeg" width="600" height="337"></picture></p>
<p>Additionally, the blur pass should be done in <mark>2 passes</mark>. This brings down the complexity of the algorithm from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>. This can be done if the used blur algorithm is a so-called <a href="https://en.wikipedia.org/wiki/Separable_filter" target="_blank" rel="noopener noreferrer">separable filter</a> which is the case both for a box blur and a gaussian blur. When doing the blur in 2 passes, the pixels get first blurred vertically, and then the vertically-blurred buffer gets blurred horizontally resulting in the final blur.</p>
<div class="images-row">
<figure><picture><source type="image/webp" srcset="blurred-buffer/vertical-blur.png-300w.webp 300w, blurred-buffer/vertical-blur.png-400w.webp 400w, blurred-buffer/vertical-blur.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="blurred-buffer/vertical-blur.png-300w.jpeg 300w, blurred-buffer/vertical-blur.png-400w.jpeg 400w, blurred-buffer/vertical-blur.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline." style="width:100%;" loading="lazy" decoding="async" src="blurred-buffer/vertical-blur.png-300w.jpeg" width="600" height="337"></picture><figcaption>Vertical blur.</figcaption></figure>
<figure><picture><source type="image/webp" srcset="blurred-buffer/horizontal-blur.png-300w.webp 300w, blurred-buffer/horizontal-blur.png-400w.webp 400w, blurred-buffer/horizontal-blur.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="blurred-buffer/horizontal-blur.png-300w.jpeg 300w, blurred-buffer/horizontal-blur.png-400w.jpeg 400w, blurred-buffer/horizontal-blur.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline." style="width:100%;" loading="lazy" decoding="async" src="blurred-buffer/horizontal-blur.png-300w.jpeg" width="600" height="337"></picture><figcaption>Horizontal blur.</figcaption></figure>
</div>
<p>A simple seperable box blur can be implemented by taking the non-weighted average around a given pixel. For a gaussian blur, the used kernel will be a gaussian kernel so that the weighted-average will be taken.</p>
<pre class="language-hlsl"><code class="language-hlsl"><span class="token comment">// Vertical box blur.</span><br><span class="token keyword">half4</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token keyword">int</span> samples <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> _KernelSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><br><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">float</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">&lt;</span> samples<span class="token punctuation">;</span> y<span class="token operator">++</span><span class="token punctuation">)</span><br><span class="token punctuation">{</span><br>    <span class="token keyword">float2</span> offset <span class="token operator">=</span> <span class="token keyword">float2</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">-</span> _KernelSize<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    sum <span class="token operator">+=</span> <span class="token function">SAMPLE_TEXTURE2D</span><span class="token punctuation">(</span>_MainTex<span class="token punctuation">,</span> sampler_MainTex<span class="token punctuation">,</span> IN<span class="token punctuation">.</span>uv <span class="token operator">+</span> offset <span class="token operator">*</span> _MainTex_TexelSize<span class="token punctuation">.</span>xy<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><span class="token keyword">return</span> sum <span class="token operator">/</span> samples<span class="token punctuation">;</span><br>                <br><span class="token comment">// Horizontal box blur.</span><br><span class="token keyword">half4</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token keyword">int</span> samples <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> _KernelSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><br><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">float</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> samples<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span><br><span class="token punctuation">{</span><br>    <span class="token keyword">float2</span> offset <span class="token operator">=</span> <span class="token keyword">float2</span><span class="token punctuation">(</span>x <span class="token operator">-</span> _KernelSize<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    sum <span class="token operator">+=</span> <span class="token function">SAMPLE_TEXTURE2D</span><span class="token punctuation">(</span>_MainTex<span class="token punctuation">,</span> sampler_MainTex<span class="token punctuation">,</span> IN<span class="token punctuation">.</span>uv <span class="token operator">+</span> offset <span class="token operator">*</span> _MainTex_TexelSize<span class="token punctuation">.</span>xy<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><span class="token keyword">return</span> sum <span class="token operator">/</span> samples<span class="token punctuation">;</span></code></pre>
<p>The outline width is controlled by the _KernelSize parameter of the blur shader.</p>
<h3>3. Outline Pass</h3>
<p>After the blur pass, the blurred silhouette gets combined with the original scene to form the outline.</p>
<p><picture><source type="image/webp" srcset="blurred-buffer/outline-only.png-300w.webp 300w, blurred-buffer/outline-only.png-400w.webp 400w, blurred-buffer/outline-only.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="blurred-buffer/outline-only.png-300w.jpeg 300w, blurred-buffer/outline-only.png-400w.jpeg 400w, blurred-buffer/outline-only.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline." style="width:;" loading="lazy" decoding="async" src="blurred-buffer/outline-only.png-300w.jpeg" width="600" height="337"></picture></p>
<p>Using a blurred buffer is great for having soft or glowing outlines, but the buffer can also be stepped to render a hard outline.</p>
<p><picture><source type="image/webp" srcset="blurred-buffer/outline-result.png-300w.webp 300w, blurred-buffer/outline-result.png-400w.webp 400w, blurred-buffer/outline-result.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="blurred-buffer/outline-result.png-300w.jpeg 300w, blurred-buffer/outline-result.png-400w.jpeg 400w, blurred-buffer/outline-result.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline." style="width:100%;" loading="lazy" decoding="async" src="blurred-buffer/outline-result.png-300w.jpeg" width="600" height="172"></picture></p>
<h3>Masking</h3>
<p>Just like for the vertex extrusion method, a stencil mask can be used to make sure the outline only gets rendered behind the geometry.</p>
<blockquote>
<p><strong>üí¨ Blurred buffer</strong> outlines are great for soft and glowy outlines but can have a bigger impact on performance compared to other methods.</p>
</blockquote>
<h2>Jump Flood Algorithm</h2>
<p>The fourth method is to use the <mark>Jump Flood algorithm</mark> to render outlines. The main advantage of this technique is that it can render really wide outlines, at a very reasonable performance cost. I won't go into details at this time since the technique has a good explanation in this <a href="https://bgolus.medium.com/the-quest-for-very-wide-outlines-ba82ed442cd9" target="_blank" rel="noopener noreferrer">article from Ben Golus</a>.</p>
<video width="50%" title="Two-pass box blur effect." loop="" autoplay="" playsinline="" muted="true" class="note-video">
<source src="jump-flood/jump-flood.mp4" type="video/mp4">
</video>
<blockquote>
<p><strong>üí¨ Jump flood</strong> outlines are a great option when you need performant, wide outlines.</p>
</blockquote>
<h2>Edge Detection</h2>
<p><picture><source type="image/webp" srcset="edge-detection/final.png-300w.webp 300w, edge-detection/final.png-400w.webp 400w, edge-detection/final.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="edge-detection/final.png-300w.jpeg 300w, edge-detection/final.png-400w.jpeg 400w, edge-detection/final.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Edge detection outline." style="width:100%;" loading="lazy" decoding="async" src="edge-detection/final.png-300w.jpeg" width="600" height="177"></picture></p>
<h3>Technique</h3>
<p>A fifth method is to use an edge-detection pass for rendering outlines. This full-screen pass draws lines by <mark>detecting discontinuities</mark> in the scene and rendering an outline between areas that have a large enough discontinuity between them. Discontinuities can be detected between the depth buffer value, the normal vector, the albedo color or any other data that is made available.</p>
<h3>Detection of discontinuity</h3>
<h4>Roberts cross</h4>
<p>Detecting discontinuities can be done by using an edge detection operator such as the <a href="https://en.wikipedia.org/wiki/Roberts_cross" target="_blank" rel="noopener noreferrer">Roberts cross operator</a>. This operator works as a differential operator by calculating the sum of the squares of the differences between diagonal pixels resulting in a cross-like pattern. In practice, edge detection operators can be applied by convolving the original image with kernels. There are 2 kernels, one for the x direction and one for the y direction. For Roberts cross, the diagonal pixels get sampled and convolved with these kernels. The kernels have a size of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>x</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">2x2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal">x</span><span class="mord">2</span></span></span></span>.</p>
<pre class="language-hlsl"><code class="language-hlsl"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> RobertsCrossX<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><br>    <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span><br>    <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> RobertsCrossY<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><br>    <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span><br>    <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>These kernels can then be used as follows.</p>
<pre class="language-hlsl"><code class="language-hlsl">horizontal <span class="token operator">+=</span> samples<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> RobertsCrossX<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// top left (factor +1)</span><br>horizontal <span class="token operator">+=</span> samples<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">*</span> RobertsCrossX<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// bottom right (factor -1)</span><br><br>vertical <span class="token operator">+=</span> samples<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">*</span> RobertsCrossY<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// bottom left (factor -1)</span><br>vertical <span class="token operator">+=</span> samples<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> RobertsCrossY<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// top right (factor +1)</span><br><br>edge <span class="token operator">=</span>  <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>horizontal<span class="token punctuation">,</span> horizontal<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">dot</span><span class="token punctuation">(</span>vertical<span class="token punctuation">,</span> vertical<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Roberts cross is a very simple operator but can already give nice results. The operator only needs 4 samples around a given pixel.</p>
<h4>Sobel operator</h4>
<p>Another method is to use a <a href="https://en.wikipedia.org/wiki/Sobel_operator" target="_blank" rel="noopener noreferrer">Sobel operator</a>. Again, 2 kernels are used but this time the kernels have a size of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mi>x</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">3x3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mord mathnormal">x</span><span class="mord">3</span></span></span></span>.</p>
<pre class="language-hlsl"><code class="language-hlsl"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> SobelX<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><br>    <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><br>    <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><br>    <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> SobelY<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><br>    <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span><br>    <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span><br>    <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>This time, 9 samples are used around a given pixel. The Sobel kernels can be used like this.</p>
<pre class="language-hlsl"><code class="language-hlsl">horizontal <span class="token operator">+=</span> samples<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> SobelX<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// top left (factor +1)</span><br>horizontal <span class="token operator">+=</span> samples<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">*</span> SobelX<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// top right (factor -1)</span><br>horizontal <span class="token operator">+=</span> samples<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">*</span> SobelX<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// center left (factor +2)</span><br>horizontal <span class="token operator">+=</span> samples<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">*</span> SobelX<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// center right (factor -2)</span><br>horizontal <span class="token operator">+=</span> samples<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">*</span> SobelX<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// bottom left (factor +1)</span><br>horizontal <span class="token operator">+=</span> samples<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">*</span> SobelX<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// bottom right (factor -1)</span><br><br>vertical <span class="token operator">+=</span> samples<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> SobelY<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// top left (factor +1)</span><br>vertical <span class="token operator">+=</span> samples<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> SobelY<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// top center (factor +2)</span><br>vertical <span class="token operator">+=</span> samples<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">*</span> SobelY<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// top right (factor +1)</span><br>vertical <span class="token operator">+=</span> samples<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">*</span> SobelY<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// bottom left (factor -1)</span><br>vertical <span class="token operator">+=</span> samples<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">*</span> SobelY<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// bottom center (factor -2)</span><br>vertical <span class="token operator">+=</span> samples<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">*</span> SobelY<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// bottom right (factor -1)</span><br><br>edge <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>horizontal<span class="token punctuation">,</span> horizontal<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">dot</span><span class="token punctuation">(</span>vertical<span class="token punctuation">,</span> vertical<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>You can read this <a href="https://jameshfisher.com/2020/08/31/edge-detection-with-sobel-filters/" target="_blank" rel="noopener noreferrer">blog post on Sobel filters</a> if you want to learn more about how Sobel filters work.</p>
<h3>Sources of discontinuity</h3>
<p>A common approach is to look for discontinuities in the textures that the render pipeline generates for the scene such as the depth texture, normals texture and color texture.</p>
<div class="images-row">
<picture><source type="image/webp" srcset="edge-detection/depth.png-300w.webp 300w, edge-detection/depth.png-400w.webp 400w, edge-detection/depth.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="edge-detection/depth.png-300w.jpeg 300w, edge-detection/depth.png-400w.jpeg 400w, edge-detection/depth.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Edge detection outline." style="width:100%;" loading="lazy" decoding="async" src="edge-detection/depth.png-300w.jpeg" width="600" height="810"></picture>
<picture><source type="image/webp" srcset="edge-detection/normals.png-300w.webp 300w, edge-detection/normals.png-400w.webp 400w, edge-detection/normals.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="edge-detection/normals.png-300w.jpeg 300w, edge-detection/normals.png-400w.jpeg 400w, edge-detection/normals.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Edge detection outline." style="width:100%;" loading="lazy" decoding="async" src="edge-detection/normals.png-300w.jpeg" width="600" height="810"></picture>
<picture><source type="image/webp" srcset="edge-detection/color.png-300w.webp 300w, edge-detection/color.png-400w.webp 400w, edge-detection/color.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="edge-detection/color.png-300w.jpeg 300w, edge-detection/color.png-400w.jpeg 400w, edge-detection/color.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Edge detection outline." style="width:100%;" loading="lazy" decoding="async" src="edge-detection/color.png-300w.jpeg" width="600" height="810"></picture>
</div>
<p>During the edge-detection pass, these textures are sampled and discontinuities are detected using the edge detection operators mentioned earlier. The resulting edge that is drawn can be caused by any discontinuity that was found in one of the 3 buffers. With this technique, the outline gets applied to all the objects that write to these buffers and so you have less control over the outlines on a per-object basis. In the image below, edge contributions by <mark>depth/normals/color</mark> are represented by the color </mark>red/green/blue</mark> respectively.</p>
<div class="images-row">
<picture><source type="image/webp" srcset="edge-detection/contribution-debug.png-300w.webp 300w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline result." style="width:100%;" loading="lazy" decoding="async" src="edge-detection/contribution-debug.png-300w.jpeg" width="300" height="292"></picture>
<picture><source type="image/webp" srcset="edge-detection/contribution-result.png-300w.webp 300w, edge-detection/contribution-result.png-400w.webp 400w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="edge-detection/contribution-result.png-300w.jpeg 300w, edge-detection/contribution-result.png-400w.jpeg 400w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline result." style="width:100%;" loading="lazy" decoding="async" src="edge-detection/contribution-result.png-300w.jpeg" width="400" height="397"></picture>
</div>
<p>Allowing discontinuities to be detected from different sources makes for a more robust outlining system. In the debug image above you can see that while some edges would be detected by all three discontinuity sources, a lot of them only get picked up from a contribution of a specific discontinuity source. Each discontinuity source can be given a different weight and different thresholds can be used for each of them, allowing you to control the visual of the outline.</p>
<h3>Edge detection modulation</h3>
<p>Usually, just using an edge detection operator on the discontinuity source buffers is not enough to get a result without artifacts. Some <mark>modulation</mark> has to be done to get rid of these artifacts. For example, since the depth buffer is <a href="https://developer.nvidia.com/content/depth-precision-visualized" target="_blank" rel="noopener noreferrer">implemented non-linearly</a> in a lot of render pipelines, two objects 1m apart located close to the camera will have a larger depth difference than two objects 1m apart located far away from the camera. To accommodate for this, the threshold used for detecting discontinuities in depth can be modulated by the depth buffer itself so that geometry located close to the camera will need to have a larger discontinuity in depth value before being detected as an edge.</p>
<pre class="language-hlsl"><code class="language-hlsl">depthThreshold <span class="token operator">*=</span> _DepthDistanceModulation <span class="token operator">*</span> <span class="token function">SampleSceneDepth</span><span class="token punctuation">(</span>uv<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>A second common artifact is unwanted edges showing up on objects at small <a href="https://en.wikipedia.org/wiki/Angle_of_incidence_(optics)#Grazing_angle_or_glancing_angle" target="_blank" rel="noopener noreferrer">grazing angles</a>. To resolve this, you can modulate with a mask that is generated from the dot product between the normal vector <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> and the view direction <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>. This is the same fresnel mask that was used in the initial outlining technique using a rim effect.</p>
<pre class="language-hlsl"><code class="language-hlsl"><span class="token keyword">float</span> fresnel <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> <span class="token function">saturate</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>normalWS<span class="token punctuation">,</span> viewWS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> _Power<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">float</span> grazingAngleMask <span class="token operator">=</span> <span class="token function">saturate</span><span class="token punctuation">(</span><span class="token punctuation">(</span>fresnel <span class="token operator">+</span> _GrazingAngleMaskPower <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> _GrazingAngleMaskPower<span class="token punctuation">)</span><span class="token punctuation">;</span><br>depthThreshold <span class="token operator">*=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">smoothstep</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">-</span> _GrazingAngleMaskHardness<span class="token punctuation">,</span> grazingAngleMask<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Other modulation techniques can be used, depending on the visual fidelity you want to achieve but these depend on the specific effect that you're after.</p>
<h3>Custom discontinuity source</h3>
<p>It is also possible to provide the outline shader with a custom discontinuity source. This would be a render texture that you create yourself during the render process, containing custom data that you wish to use to generate outlines. The advantage is that since you control what writes to this custom buffer, you can control which objects receive an outline.</p>
<div class="images-row">
<picture><source type="image/webp" srcset="edge-detection/custom-buffer-source.png-300w.webp 300w, edge-detection/custom-buffer-source.png-400w.webp 400w, edge-detection/custom-buffer-source.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="edge-detection/custom-buffer-source.png-300w.jpeg 300w, edge-detection/custom-buffer-source.png-400w.jpeg 400w, edge-detection/custom-buffer-source.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline result." style="width:100%;" loading="lazy" decoding="async" src="edge-detection/custom-buffer-source.png-300w.jpeg" width="600" height="600"></picture>
<picture><source type="image/webp" srcset="edge-detection/custom-buffer-result.png-300w.webp 300w, edge-detection/custom-buffer-result.png-400w.webp 400w, edge-detection/custom-buffer-result.png-600w.webp 600w" sizes="(min-width: 30em) 50vw, 100vw"><source type="image/jpeg" srcset="edge-detection/custom-buffer-result.png-300w.jpeg 300w, edge-detection/custom-buffer-result.png-400w.jpeg 400w, edge-detection/custom-buffer-result.png-600w.jpeg 600w" sizes="(min-width: 30em) 50vw, 100vw"><img class="note-image" alt="Blurred buffer outline result." style="width:100%;" loading="lazy" decoding="async" src="edge-detection/custom-buffer-result.png-300w.jpeg" width="600" height="600"></picture>
</div>
<p>For example in the scene above, the discontinuity source is generated by rendering the vertex colors of a mesh to a texture. Other techniques that come to mind are coloring faces based on their world position or creating a custom buffer that combines both information from the depth buffer and the normals buffer.</p>
<blockquote>
<p><strong>üí¨ Edge detection</strong> outlines are good when you need a full-screen outlining effect. Some finetuning is needed to prevent lines from showing up where you don't want them to.</p>
</blockquote>
<h2>Conclusion</h2>
<p>There you go, 5 ways to draw an outline. They all have their benefits, making trade-offs between performance, visual fidelity and manual setup that is required.</p>
<h2>Credits</h2>
<blockquote>
<p><strong>üí¨</strong> The Sailor Moon 3D models used in this post were made by <em>premudraya</em> over on Sketchfab.</p>
</blockquote>
<blockquote>
<p><strong>üí¨</strong> The Zelda 3D model used in this post was made by <em>theStoff</em> over on Sketchfab.</p>
</blockquote>
<h2>Additional Resources</h2>
<h3>Vertex Extrusion</h3>
<p><a href="https://www.videopoetics.com/tutorials/pixel-perfect-outline-shaders-unity/#working-in-clip-space" target="_blank" rel="noopener noreferrer">https://www.videopoetics.com/tutorials/pixel-perfect-outline-shaders-unity</a></p>
<h3>Jump Flood Algorithm</h3>
<p><a href="https://bgolus.medium.com/the-quest-for-very-wide-outlines-ba82ed442cd9" target="_blank" rel="noopener noreferrer">https://bgolus.medium.com/the-quest-for-very-wide-outlines-ba82ed442cd9</a></p>
<h3>Edge Detection</h3>
<p><a href="https://roystan.net/articles/outline-shader.html" target="_blank" rel="noopener noreferrer">https://roystan.net/articles/outline-shader.html</a></p>
<p><a href="https://jameshfisher.com/2020/08/31/edge-detection-with-sobel-filters/" target="_blank" rel="noopener noreferrer">https://jameshfisher.com/2020/08/31/edge-detection-with-sobel-filters</a></p>


        <div id="back-to-top-desktop" class="back-to-top-desktop">
            <a href="#" aria-label="Back to top of page.">
                <span class="icon-arrow-up"></span></a>
            <!-- this could link to #top and then you have <a name="top"></a> somewhere so you can link to specific spots -->
        </div>

            <div id="back-to-top-mobile" class="back-to-top-mobile">
            <a href="#" aria-label="Back to top of page.">
                <span class="icon-arrow-up"></span></a>
            <!-- this could link to #top and then you have <a name="top"></a> somewhere so you can link to specific spots -->
        </div>



         <div class="note-date"><time>August 16, 2021</time></div>
    </div>

    <footer class="note-footer">
    <ul class="note-tags"><li>
                <a style="--tag-bg: #d4f0ff; --tag-text: #04509c;" href="/tags/graphics">graphics</a>
            </li><li>
                <a style="--tag-bg: #ccffe0; --tag-text: #1b715c;" href="/tags/unity">unity</a>
            </li></ul>

    <div>
        <a href="https://twitter.com/alexanderameye" rel="noopener" target="_blank" aria-label="Alexander Ameye Twitter.">
            <span class="icon-twitter footer-icon"></span></a>
        <a href="https://www.linkedin.com/in/alexander-ameye-067a0b70/" rel="noopener" target="_blank" aria-label="Alexander Ameye LinkedIn.">
            <span class="icon-linkedin footer-icon"></span></a>
        <a href="https://github.com/alexanderameye" rel="noopener" target="_blank" aria-label="Alexander Ameye GitHub.">
            <span class="icon-github footer-icon"></span></a>
    </div>
</footer>

 
</div>

<script src="https://storage.ko-fi.com/cdn/scripts/overlay-widget.js"></script>
<script>
  kofiWidgetOverlay.draw('alexanderameye', {
    'type': 'floating-chat',
    'floating-chat.donateButton.text': 'Support me',
    'floating-chat.donateButton.background-color': '#323842',
    'floating-chat.donateButton.text-color': '#fff'
  });
</script>
    </body>
</html>